;-*-Lisp-*-

(letrec
    ((action (lambda (i pid a) (cons 'action (cons i (cons pid (cons a ()))))))

     (withdraw (lambda (n) (cons 'withdraw (cons n ()))))
     (deposit (lambda (n) (cons 'deposit (cons n ()))))
     (publish (lambda (i pid) (cons 'publish (cons i (cons pid ())))))
     (require (lambda (v) (cons 'require (cons v ()))))

     ;; constructors for basic monadic operators
     ;; not to be used in contract-specific code
     (mk-pure (lambda (a) (cons 'pure (cons a ()))))
     (mk-bind (lambda (a b) (cons 'bind (cons a (cons b ())))))
     (mk-next (lambda (a b) (cons 'next (cons a (cons b ())))))

     ;; those can be used in contract-specyfic code
     ;; synonyms introduced since in alternative versions we consider those
     ;; to be diferent from "internal" representation
     (pure mk-pure)
     (bind mk-bind)
     (next mk-next)

     
     (digestPrim (lambda (a) (cons 'digest (cons a ()) )))

     (eqPrim (lambda (a b) (eq a b)))

     
     ;;TODO handle those on transpiler level! make configurable
     (DIGESTNAT digestPrim)
     (==Digest eqPrim)
     (==Nat eqPrim)
     
      
     (sucNat (lambda (x) ( if (eq x ())
			      '(t)
			      (if (car x) (cons nil (sucNat (cdr x))) (cons t (cdr x)))
			       )))
     
     (+ℕh (lambda (a b carry)
            (if (eq a ()) (if carry (sucNat b) b)
		(if (eq b ()) (if carry (sucNat a) a)
		    (if (car a)
			(if (car b) (cons carry (+ℕh (cdr a) (cdr b) t)) (cons (if carry () t) (+ℕh (cdr a) (cdr b) carry)))
			(if (car b) (cons (if carry () t) (+ℕh (cdr a) (cdr b) carry)) (cons carry (+ℕh (cdr a) (cdr b) ())))
		     )))
     	    ))
     (+ℕ (lambda (a b) (+ℕh a b ())))
     (+Nat +ℕ)

     ;; consider soemthing more efficeint here
     (*ℕ (lambda (a b) (if a (+Nat (if (car a) b ()) (cons () (*ℕ (cdr a) b))) () ) ))
     
     ;; ONLY make sense for small numbers!!, may be helpful for testing but shuld NOT be used in prod version, unles in provably safe context
     (PF->Nat (lambda (a) (if (eq 0 a) () (sucNat (PF->Nat (- a 1))))))
     
     (Nat->PF (lambda (a) (if a (+ (if (car a) 1 0) (* 2 (Nat->PF (cdr a)))) 0)))

     
     (^^^ (lambda (a b) 
		    (if (eq a ()) b
			(if (eq b ()) a
			    (let ((hd ( if (car a) (if (car b) NIL t ) b )) 
				  (tail (^^^ (cdr a) (cdr b) )))
			      (if tail (cons hd tail) hd)
			      )))))

     (&&& (lambda (a b) 
		    (if (eq a ()) ()
			(if (eq b ()) ()
			    ( let ((hd ( if (car a) (car b) NIL ) )
				   (tail (&&& (cdr a) (cdr b) )))
			       (if tail (cons hd tail) hd)
			      )
			    ))))

     (atomic-action-rec (lambda (code case-bind case-next case-pure case-require case-atom)
			  (if (eq (car code) 'bind)
			      (case-bind (car (cdr code)) (car (cdr (cdr code))))
			      (if (eq (car code) 'next) (case-next (car (cdr code)) (car (cdr (cdr code))))
			      (if (eq (car code) 'pure) (case-pure (car (cdr code)))
				  (if (eq (car code) 'require) (case-require (car (cdr code)))
				      (case-atom code (car (cdr code)) (car code)))))

			   )))
     ;; returns : ((pubs start) result) or t or NIL
     (run-glow (lambda (pubs code start target)
		 (atomic-action-rec code
				    (lambda (code-a fun-b)
				      (let ((result-a (run-glow pubs code-a start target)))
					   
					(if (atom result-a) result-a
					    (let ((pubs2 (car (car result-a)))
						  (code2 (fun-b (car (cdr result-a))))
						  (start2 (car (cdr (car result-a)))))
					           (run-glow pubs2 code2 start2 target)
						   ))))
				    (lambda (code-a code-b)
				      (let ((result-a (run-glow pubs code-a start target)))
					   
					(if (atom result-a) result-a
					    (let ((pubs2 (car (car result-a)))
						  (start2 (car (cdr (car result-a)))))
					           (run-glow pubs2 code-b start2 target)
						  ))))
				    (lambda (x) (cons (cons pubs (cons start ())) (cons x ())))
				    (lambda (x) (if x (cons (cons pubs (cons start ())) (cons x ())) 'require-fail))
				    (lambda (a id h)
				                  ( if start
                                                          (let ((new-start (if (eq start id) NIL start ))
								(new-pubs (if (eq h 'publish) (cdr pubs) pubs))
								(result (if (eq h 'publish) (car pubs) 'glow-unit-lit)))
							       (cons (cons new-pubs (cons new-start ())) (cons result ())))
						             
							  (eq a target)
							  )
					    )
				    )

		))
     )
  (current-env)
  
  )
